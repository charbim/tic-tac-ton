<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Ultimate Tic-Tac-Toe</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
          'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
          sans-serif;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        min-height: 100vh;
        padding: 20px;
        position: relative;
        overflow-x: hidden;
        background-color: #ff0000;
        transition: background-color 1.5s ease;
      }

      body::before {
        content: attr(data-symbol);
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 60vw;
        font-weight: bold;
        opacity: 0.08;
        pointer-events: none;
        transition: opacity 1.5s ease;
        z-index: 0;
        color: white;
        white-space: nowrap;
      }

      body::after {
        content: '';
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: -1;
        transition: opacity 1.5s ease;
        background: linear-gradient(135deg, rgba(0, 0, 0, 0.15) 0%, rgba(0, 0, 0, 0.25) 50%, rgba(0, 0, 0, 0.35) 100%);
      }

      body.x {
        background-color: #ff0000;
      }

      body.x::after {
        opacity: 1;
      }

      body.o {
        background-color: #0066ff;
      }

      body.o::after {
        opacity: 1;
      }

      .container {
        background: transparent;
        padding: 40px;
        text-align: center;
        max-width: 1200px;
        width: 100%;
        position: relative;
        z-index: 1;
      }

      h1 {
        margin-bottom: 30px;
        color: white;
        font-size: 2.5em;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
      }


      .meta-board-container {
        background: rgba(255, 255, 255, 0.15);
        border-radius: 20px;
        padding: 20px;
        width: 100%;
        max-width: 940px;
        margin: 0 auto;
        position: relative;
      }

      .meta-board {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 0;
        width: 100%;
        max-width: 900px;
        margin: 0 auto;
        padding: 0;
        background: transparent;
        border-radius: 20px;
        position: relative;
        align-items: stretch;
      }

      .mini-board-wrapper {
        position: relative;
        background: transparent;
        padding: 0;
        aspect-ratio: 1;
        box-sizing: border-box;
        margin: 0;
        overflow: hidden;
        transition: box-shadow 0.25s ease, background 0.25s ease;
      }

      .mini-board-wrapper.active {
        box-shadow: 0 0 0 4px rgba(255, 255, 255, 0.85);
        background: rgba(255, 255, 255, 0.08);
        border-radius: 14px;
      }

      /* Add major grid lines between mini boards - horizontal lines (between rows, not around edges) */
      .mini-board-wrapper:nth-child(4),
      .mini-board-wrapper:nth-child(5),
      .mini-board-wrapper:nth-child(6),
      .mini-board-wrapper:nth-child(7),
      .mini-board-wrapper:nth-child(8),
      .mini-board-wrapper:nth-child(9) {
        border-top: 4px solid rgba(255, 255, 255, 0.5);
      }

      /* Add major grid lines between mini boards - vertical lines (between columns, not around edges) */
      .mini-board-wrapper:nth-child(2),
      .mini-board-wrapper:nth-child(3),
      .mini-board-wrapper:nth-child(5),
      .mini-board-wrapper:nth-child(6),
      .mini-board-wrapper:nth-child(8),
      .mini-board-wrapper:nth-child(9) {
        border-left: 4px solid rgba(255, 255, 255, 0.5);
      }

      .mini-board {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        width: 100%;
        height: 100%;
        gap: 0;
        position: relative;
        box-sizing: border-box;
        align-items: stretch;
      }

      .mini-cell {
        background: transparent;
        border: none; /* reset default button border */
        border-right: 2px solid rgba(255, 255, 255, 0.3);
        border-bottom: 2px solid rgba(255, 255, 255, 0.3);
        font-size: 2.5em;
        font-weight: bold;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        aspect-ratio: 1;
        padding: 0;
        margin: 0;
        user-select: none;
        min-height: 0;
        box-sizing: border-box;
        position: relative;
        width: 100%;
        height: 100%;
      }

      /* Turn-based cursor: red X on X's turn, blue O on O's turn */
      body.x .mini-cell:not(:disabled) {
        cursor: url("data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20width='32'%20height='32'%20viewBox='0%200%2032%2032'%3E%3Cpath%20d='M8%208L24%2024M24%208L8%2024'%20stroke='%23000000'%20stroke-opacity='0.85'%20stroke-width='7'%20stroke-linecap='round'/%3E%3Cpath%20d='M8%208L24%2024M24%208L8%2024'%20stroke='%23b01212'%20stroke-width='4'%20stroke-linecap='round'/%3E%3C/svg%3E") 16 16, pointer;
      }

      body.o .mini-cell:not(:disabled) {
        cursor: url("data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20width='32'%20height='32'%20viewBox='0%200%2032%2032'%3E%3Ccircle%20cx='16'%20cy='16'%20r='9'%20fill='none'%20stroke='%23000000'%20stroke-opacity='0.85'%20stroke-width='7'/%3E%3Ccircle%20cx='16'%20cy='16'%20r='9'%20fill='none'%20stroke='%230a45cc'%20stroke-width='4'/%3E%3C/svg%3E") 16 16, pointer;
      }

      /* Remove right border on rightmost cells of each mini board */
      .mini-cell:nth-child(3n) {
        border-right: none;
      }

      /* Remove bottom border on bottommost cells of each mini board */
      .mini-cell:nth-child(n+7) {
        border-bottom: none;
      }

      .mini-cell:hover:not(:disabled) {
        background: transparent;
      }

      .mini-cell.x {
        color: red;
      }

      .mini-cell.o {
        color: blue;
      }

      .mini-cell:disabled {
        cursor: not-allowed;
        opacity: 0.7;
      }

      .mini-board-winner {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 20em;
        font-weight: bold;
        pointer-events: none;
        z-index: 10;
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .mini-board-winner.x {
        color: red;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
      }

      .mini-board-winner.o {
        color: blue;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
      }

      .winning-line {
        position: absolute;
        z-index: 9;
        pointer-events: none;
        border-radius: 2px;
      }

      .winning-line.x {
        background-color: red;
      }

      .winning-line.o {
        background-color: blue;
      }

      .winning-line.horizontal.row-0 {
        width: 90%;
        height: 6px;
        top: 16.66%;
        left: 5%;
        transform: translateY(-50%);
      }

      .winning-line.horizontal.row-1 {
        width: 90%;
        height: 6px;
        top: 50%;
        left: 5%;
        transform: translateY(-50%);
      }

      .winning-line.horizontal.row-2 {
        width: 90%;
        height: 6px;
        top: 83.33%;
        left: 5%;
        transform: translateY(-50%);
      }

      .winning-line.vertical.col-0 {
        width: 6px;
        height: 90%;
        left: 16.66%;
        top: 5%;
        transform: translateX(-50%);
      }

      .winning-line.vertical.col-1 {
        width: 6px;
        height: 90%;
        left: 50%;
        top: 5%;
        transform: translateX(-50%);
      }

      .winning-line.vertical.col-2 {
        width: 6px;
        height: 90%;
        left: 83.33%;
        top: 5%;
        transform: translateX(-50%);
      }

      .winning-line.diagonal-1 {
        width: 90%;
        height: 6px;
        top: 50%;
        left: 5%;
        transform: translateY(-50%) rotate(45deg);
        transform-origin: center;
      }

      .winning-line.diagonal-2 {
        width: 90%;
        height: 6px;
        top: 50%;
        left: 5%;
        transform: translateY(-50%) rotate(-45deg);
        transform-origin: center;
      }

      .mini-board.draw {
        background: rgba(128, 128, 128, 0.2);
      }

      .mini-board-wrapper.won .mini-cell {
        opacity: 0.3;
      }

      .message {
        margin-top: 20px;
        font-size: 1.2em;
        font-weight: bold;
        min-height: 30px;
        color: white;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
      }

      .reset-btn {
        margin-top: 20px;
        padding: 12px 30px;
        font-size: 1em;
        background: #667eea;
        color: white;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        font-weight: bold;
        transition: background 0.3s;
      }

      .reset-btn:hover {
        background: #5568d3;
      }

      .hidden {
        display: none !important;
      }

      .scores-btn {
        position: fixed;
        top: 20px;
        right: 20px;
        z-index: 50;
        padding: 10px 14px;
        font-size: 0.95em;
        background: rgba(0, 0, 0, 0.35);
        color: white;
        border: 1px solid rgba(255, 255, 255, 0.25);
        border-radius: 10px;
        cursor: pointer;
        font-weight: 700;
        backdrop-filter: blur(6px);
        -webkit-backdrop-filter: blur(6px);
        transition: transform 0.15s ease, background 0.15s ease, border-color 0.15s ease;
      }

      .scores-btn:hover {
        transform: translateY(-1px);
        background: rgba(0, 0, 0, 0.45);
        border-color: rgba(255, 255, 255, 0.35);
      }

      .auth-btn {
        position: fixed;
        top: 20px;
        left: 20px;
        z-index: 50;
        padding: 10px 14px;
        font-size: 0.95em;
        background: rgba(0, 0, 0, 0.35);
        color: white;
        border: 1px solid rgba(255, 255, 255, 0.25);
        border-radius: 10px;
        cursor: pointer;
        font-weight: 700;
        backdrop-filter: blur(6px);
        -webkit-backdrop-filter: blur(6px);
        transition: transform 0.15s ease, background 0.15s ease, border-color 0.15s ease;
      }

      .auth-btn:hover {
        transform: translateY(-1px);
        background: rgba(0, 0, 0, 0.45);
        border-color: rgba(255, 255, 255, 0.35);
      }

      .auth-btn[disabled] {
        opacity: 0.6;
        cursor: not-allowed;
        transform: none;
      }

      .auth {
        padding: 10px 16px 18px 16px;
      }

      .auth-subtitle {
        margin-top: 6px;
        opacity: 0.85;
        font-size: 0.95em;
        line-height: 1.35;
      }

      .auth-mode-toggle {
        display: flex;
        gap: 8px;
        margin-top: 12px;
      }

      .auth-mode-toggle button {
        padding: 10px 12px;
        border-radius: 10px;
        border: 1px solid rgba(255, 255, 255, 0.18);
        background: rgba(255, 255, 255, 0.08);
        color: white;
        cursor: pointer;
        font-weight: 700;
      }

      .auth-mode-toggle button[aria-pressed="true"] {
        background: rgba(255, 255, 255, 0.18);
        border-color: rgba(255, 255, 255, 0.28);
      }

      .auth-form {
        display: grid;
        gap: 10px;
        margin-top: 14px;
      }

      .auth-form input {
        width: 100%;
        padding: 12px 14px;
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.18);
        background: rgba(255, 255, 255, 0.08);
        color: white;
        font-size: 1em;
        outline: none;
      }

      .auth-form input::placeholder {
        color: rgba(255, 255, 255, 0.7);
      }

      .auth-actions {
        display: flex;
        gap: 10px;
        margin-top: 12px;
      }

      .auth-actions button {
        padding: 10px 14px;
        border-radius: 12px;
        border: none;
        cursor: pointer;
        font-weight: 800;
      }

      .auth-actions .auth-primary {
        background: rgba(255, 255, 255, 0.92);
        color: rgba(0, 0, 0, 0.9);
      }

      .auth-actions .auth-secondary {
        background: rgba(0, 0, 0, 0.35);
        color: white;
        border: 1px solid rgba(255, 255, 255, 0.25);
      }

      .auth-error {
        margin-top: 12px;
        padding: 10px 12px;
        border-radius: 12px;
        border: 1px solid rgba(255, 80, 80, 0.35);
        background: rgba(255, 80, 80, 0.14);
        color: rgba(255, 225, 225, 0.98);
        font-size: 0.95em;
        line-height: 1.35;
      }

      .modal {
        position: fixed;
        inset: 0;
        z-index: 100;
        display: grid;
        place-items: center;
        padding: 20px;
      }

      .modal-backdrop {
        position: absolute;
        inset: 0;
        background: rgba(0, 0, 0, 0.55);
      }

      .modal-panel {
        position: relative;
        width: min(640px, 100%);
        max-height: min(80vh, 720px);
        overflow: auto;
        border-radius: 14px;
        background: rgba(20, 20, 20, 0.85);
        color: white;
        border: 1px solid rgba(255, 255, 255, 0.18);
        box-shadow: 0 20px 70px rgba(0, 0, 0, 0.55);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
      }

      .modal-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        padding: 14px 16px 0 16px;
      }

      .modal-title {
        font-size: 1.15em;
        font-weight: 800;
        letter-spacing: 0.2px;
      }

      .modal-close {
        appearance: none;
        border: none;
        background: rgba(255, 255, 255, 0.12);
        color: white;
        width: 36px;
        height: 36px;
        border-radius: 10px;
        cursor: pointer;
        font-size: 20px;
        line-height: 1;
        display: grid;
        place-items: center;
        transition: background 0.15s ease;
      }

      .modal-close:hover {
        background: rgba(255, 255, 255, 0.18);
      }

      .leaderboard {
        margin-top: 10px;
        padding: 12px 16px 16px 16px;
        border-radius: 12px;
        background: transparent;
        color: white;
        text-align: left;
      }

      .leaderboard h2 {
        display: none; /* title lives in modal header now */
      }

      .leaderboard-subtitle {
        font-size: 0.9em;
        opacity: 0.8;
        margin-bottom: 10px;
      }

      .leaderboard-prompt {
        margin-top: 6px;
        margin-bottom: 10px;
        font-weight: 500;
      }

      .leaderboard-form {
        display: flex;
        gap: 10px;
        margin-bottom: 12px;
      }

      .leaderboard-form input {
        flex: 1;
        padding: 8px 10px;
        border-radius: 6px;
        border: none;
        font-size: 0.95em;
      }

      .leaderboard-form button {
        padding: 8px 14px;
        border-radius: 6px;
        border: none;
        background: #48bb78;
        color: white;
        font-weight: 600;
        cursor: pointer;
        font-size: 0.95em;
        transition: background 0.2s ease;
      }

      .leaderboard-form button:hover {
        background: #38a169;
      }

      .leaderboard-list ol {
        list-style: decimal;
        padding-left: 20px;
      }

      .leaderboard-item {
        display: flex;
        justify-content: space-between;
        padding: 2px 0;
        font-size: 0.95em;
      }

      .leaderboard-name {
        font-weight: 500;
      }

      .leaderboard-wins {
        opacity: 0.85;
      }

      .leaderboard-empty {
        font-size: 0.9em;
        opacity: 0.8;
      }
    </style>
  </head>
  <body class="x" data-symbol="X">
      <button id="authButton" class="auth-btn" type="button" aria-haspopup="dialog" aria-controls="authModal">
        Sign in
      </button>
      <button id="scoresButton" class="scores-btn" type="button" aria-haspopup="dialog" aria-controls="leaderboardModal">
        Scores
      </button>
      <div class="container">
      <h1>Ultimate Tic-Tac-Toe</h1>
      <div class="meta-board-container">
        <div class="meta-board" id="metaBoard"></div>
      </div>
      <div class="message" id="message"></div>
      <button class="reset-btn" onclick="resetGame()">Reset Game</button>
    </div>

    <div id="leaderboardModal" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="leaderboardModalTitle" aria-hidden="true">
      <div class="modal-backdrop" data-modal-close></div>
      <div class="modal-panel">
        <div class="modal-header">
          <div id="leaderboardModalTitle" class="modal-title">Scores</div>
          <button id="leaderboardClose" class="modal-close" type="button" aria-label="Close scores">×</button>
        </div>
        <div id="leaderboardSection" class="leaderboard">
          <h2>Leaderboard</h2>
          <p id="leaderboardSubtitle" class="leaderboard-subtitle">Scores are stored privately for this device only.</p>
          <p id="leaderboardPrompt" class="leaderboard-prompt hidden"></p>
          <form id="leaderboardForm" class="leaderboard-form hidden">
            <input
              id="playerNameInput"
              type="text"
              name="playerName"
              placeholder="Enter winner's name"
              autocomplete="off"
              required
            />
            <button type="submit">Save win</button>
          </form>
          <div id="leaderboardList" class="leaderboard-list"></div>
        </div>
      </div>
    </div>

    <div id="authModal" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="authModalTitle" aria-hidden="true">
      <div class="modal-backdrop" data-modal-close="auth"></div>
      <div class="modal-panel">
        <div class="modal-header">
          <div id="authModalTitle" class="modal-title">Account</div>
          <button id="authClose" class="modal-close" type="button" aria-label="Close account">×</button>
        </div>
        <div class="auth">
          <div id="authStatusText" class="auth-subtitle"></div>
          <div class="auth-mode-toggle" role="group" aria-label="Account mode">
            <button id="authModeSignIn" type="button" aria-pressed="true">Sign in</button>
            <button id="authModeCreate" type="button" aria-pressed="false">Create account</button>
          </div>
          <form id="authForm" class="auth-form">
            <input
              id="authUsername"
              type="text"
              placeholder="Username"
              autocomplete="username"
              required
            />
            <input
              id="authPassword"
              type="password"
              placeholder="Password"
              autocomplete="current-password"
              required
            />
            <div class="auth-actions">
              <button id="authSubmitButton" class="auth-primary" type="submit">Sign in</button>
              <button id="authSignOutButton" class="auth-secondary hidden" type="button">Sign out</button>
            </div>
          </form>
          <div id="authError" class="auth-error hidden"></div>
          <div class="auth-subtitle" style="margin-top: 12px;">
            Accounts are stored in Firebase and work across devices. (This project treats “username” as your login.)
          </div>
        </div>
      </div>
    </div>

    <script type="module">
      import { auth, db, ensureAnonUser } from '/src/firebase.js'
      import {
        collection,
        doc,
        getDocs,
        query,
        where,
        setDoc,
        increment,
      } from 'firebase/firestore'
      import {
        EmailAuthProvider,
        createUserWithEmailAndPassword,
        linkWithCredential,
        onAuthStateChanged,
        signInWithEmailAndPassword,
        signOut,
        updateProfile,
      } from 'firebase/auth'

      let currentPlayer = 'x';
      let gameOver = false;
      let currentUser = null;
      let leaderboardEntries = [];
      let lastGameWinnerSymbol = null;

      // Each mini board is a 3x3 grid (9 cells)
      // We have 9 mini boards, so 9x9 = 81 total cells
      // Structure: boards[miniBoardIndex][cellIndex]
      let boards = Array(9).fill(null).map(() => Array(9).fill(''));
      let miniBoardWinners = Array(9).fill(''); // 'x', 'o', 'draw', or ''
      let activeMiniBoardIndex = null; // null means any board is allowed

      const metaBoardElement = document.getElementById('metaBoard');
      const messageElement = document.getElementById('message');
      const bodyElement = document.body;
      const scoresButton = document.getElementById('scoresButton');
      const leaderboardModal = document.getElementById('leaderboardModal');
      const leaderboardModalTitle = document.getElementById('leaderboardModalTitle');
      const leaderboardClose = document.getElementById('leaderboardClose');
      const leaderboardSection = document.getElementById('leaderboardSection');
      const leaderboardSubtitle = document.getElementById('leaderboardSubtitle');
      const leaderboardPrompt = document.getElementById('leaderboardPrompt');
      const leaderboardForm = document.getElementById('leaderboardForm');
      const playerNameInput = document.getElementById('playerNameInput');
      const leaderboardList = document.getElementById('leaderboardList');
      const leaderboardSubmitButton = leaderboardForm
        ? leaderboardForm.querySelector('button[type="submit"]')
        : null;

      const authButton = document.getElementById('authButton');
      const authModal = document.getElementById('authModal');
      const authClose = document.getElementById('authClose');
      const authModeSignIn = document.getElementById('authModeSignIn');
      const authModeCreate = document.getElementById('authModeCreate');
      const authForm = document.getElementById('authForm');
      const authUsername = document.getElementById('authUsername');
      const authPassword = document.getElementById('authPassword');
      const authSubmitButton = document.getElementById('authSubmitButton');
      const authSignOutButton = document.getElementById('authSignOutButton');
      const authError = document.getElementById('authError');
      const authStatusText = document.getElementById('authStatusText');

      let authMode = 'signIn'; // 'signIn' | 'create'

      function setAuthError(message) {
        if (!authError) return;
        if (!message) {
          authError.textContent = '';
          authError.classList.add('hidden');
          return;
        }
        authError.textContent = message;
        authError.classList.remove('hidden');
      }

      function usernameToEmail(username) {
        const raw = (username || '').trim().toLowerCase();
        const cleaned = raw.replace(/[^a-z0-9._-]/g, '_');
        if (!/[a-z0-9]/.test(cleaned)) return null;
        return `${cleaned}@tic-tac-ton.invalid`;
      }

      function displayUsernameForUser(user) {
        if (!user) return '';
        if (user.displayName) return user.displayName;
        const email = user.email || '';
        const localPart = email.split('@')[0] || '';
        return localPart || 'Account';
      }

      function setAuthMode(nextMode) {
        authMode = nextMode;
        setAuthError('');

        const isCreate = authMode === 'create';
        if (authModeSignIn) authModeSignIn.setAttribute('aria-pressed', String(!isCreate));
        if (authModeCreate) authModeCreate.setAttribute('aria-pressed', String(isCreate));

        if (authSubmitButton) authSubmitButton.textContent = isCreate ? 'Create account' : 'Sign in';
        if (authPassword) authPassword.autocomplete = isCreate ? 'new-password' : 'current-password';
      }

      function openAuthModal() {
        if (!authModal) return;
        setAuthError('');
        authModal.classList.remove('hidden');
        authModal.setAttribute('aria-hidden', 'false');
        setTimeout(() => {
          if (authUsername) authUsername.focus();
        }, 0);
      }

      function closeAuthModal() {
        if (!authModal) return;
        authModal.classList.add('hidden');
        authModal.setAttribute('aria-hidden', 'true');
        setAuthError('');
      }

      function updateLeaderboardSubtitleForUser(user) {
        if (!leaderboardSubtitle) return;
        if (!user || user.isAnonymous) {
          leaderboardSubtitle.textContent = 'Scores are stored privately for this device only.';
          return;
        }
        leaderboardSubtitle.textContent = 'Scores are synced to your account across devices.';
      }

      function updateAuthUiForUser(user) {
        const firebaseReady = Boolean(auth);
        if (authButton) {
          authButton.disabled = !firebaseReady;
          if (!firebaseReady) {
            authButton.textContent = 'Sign in (disabled)';
          } else if (!user || user.isAnonymous) {
            authButton.textContent = 'Sign in';
          } else {
            authButton.textContent = displayUsernameForUser(user);
          }
        }

        if (authStatusText) {
          if (!firebaseReady) {
            authStatusText.textContent =
              'Firebase is not configured. Add your Firebase keys in a .env.local file to enable sign-in.';
          } else if (!user) {
            authStatusText.textContent = 'Not signed in.';
          } else if (user.isAnonymous) {
            authStatusText.textContent = 'You are currently playing anonymously (device-only).';
          } else {
            authStatusText.textContent = `Signed in as ${displayUsernameForUser(user)}.`;
          }
        }

        if (authSignOutButton) {
          if (user && !user.isAnonymous) authSignOutButton.classList.remove('hidden');
          else authSignOutButton.classList.add('hidden');
        }
      }

      // Modal is used for two flows:
      // - viewing scores ("scores")
      // - submitting a win after a game finishes ("submitWin")
      let leaderboardModalMode = 'scores';
      let winSubmissionConsumed = false;

      function openLeaderboardModal({ focusNameInput = false } = {}) {
        if (!leaderboardModal) return;
        leaderboardModal.classList.remove('hidden');
        leaderboardModal.setAttribute('aria-hidden', 'false');
        if (focusNameInput && playerNameInput) {
          // delay focus until the modal is visible
          setTimeout(() => playerNameInput.focus(), 0);
        }
      }

      function closeLeaderboardModal() {
        if (!leaderboardModal) return;
        leaderboardModal.classList.add('hidden');
        leaderboardModal.setAttribute('aria-hidden', 'true');
      }

      function setLeaderboardModalToScoresView() {
        leaderboardModalMode = 'scores';
        winSubmissionConsumed = false;

        if (leaderboardModalTitle) leaderboardModalTitle.textContent = 'Scores';
        if (leaderboardPrompt) {
          leaderboardPrompt.textContent = '';
          leaderboardPrompt.classList.add('hidden');
        }
        if (leaderboardForm) leaderboardForm.classList.add('hidden');
        if (leaderboardList) leaderboardList.classList.remove('hidden');
        if (playerNameInput) playerNameInput.disabled = false;
        if (leaderboardSubmitButton) {
          leaderboardSubmitButton.disabled = false;
          leaderboardSubmitButton.textContent = 'Save win';
        }
      }

      function setLeaderboardModalToWinSubmissionView(winnerSymbol) {
        leaderboardModalMode = 'submitWin';
        winSubmissionConsumed = false;

        if (leaderboardModalTitle) leaderboardModalTitle.textContent = 'Submit win';
        if (leaderboardList) leaderboardList.classList.add('hidden');

        if (leaderboardPrompt) {
          leaderboardPrompt.textContent = `Player ${winnerSymbol.toUpperCase()} won! Enter a name to save this win:`;
          leaderboardPrompt.classList.remove('hidden');
        }
        if (leaderboardForm) leaderboardForm.classList.remove('hidden');
        if (playerNameInput) {
          playerNameInput.disabled = false;
          playerNameInput.value = '';
        }
        if (leaderboardSubmitButton) {
          leaderboardSubmitButton.disabled = false;
          leaderboardSubmitButton.textContent = 'Save win';
        }
      }

      function finishWinSubmissionFlow({ resetBoard } = { resetBoard: true }) {
        // Restore modal back to scores view for the next time it's opened.
        setLeaderboardModalToScoresView();
        closeLeaderboardModal();
        if (resetBoard) resetGame();
      }

      if (scoresButton) {
        scoresButton.addEventListener('click', () => {
          // Viewing scores should always show the scores view.
          setLeaderboardModalToScoresView();
          openLeaderboardModal();
        });
      }

      if (leaderboardClose) {
        leaderboardClose.addEventListener('click', () => {
          // If the game just ended, the X acts as "bypass" and resets the board.
          if (leaderboardModalMode === 'submitWin') {
            finishWinSubmissionFlow({ resetBoard: true });
            return;
          }
          closeLeaderboardModal();
        });
      }

      if (leaderboardModal) {
        leaderboardModal.addEventListener('click', (event) => {
          const target = event.target;
          if (target && target instanceof HTMLElement && target.hasAttribute('data-modal-close')) {
            // Backdrop click: bypass in submit flow, normal close otherwise.
            if (leaderboardModalMode === 'submitWin') {
              finishWinSubmissionFlow({ resetBoard: true });
              return;
            }
            closeLeaderboardModal();
          }
        });
      }

      if (authButton) {
        authButton.addEventListener('click', () => openAuthModal());
      }

      if (authClose) {
        authClose.addEventListener('click', () => closeAuthModal());
      }

      if (authModal) {
        authModal.addEventListener('click', (event) => {
          const target = event.target;
          if (
            target &&
            target instanceof HTMLElement &&
            target.getAttribute('data-modal-close') === 'auth'
          ) {
            closeAuthModal();
          }
        });
      }

      if (authModeSignIn) authModeSignIn.addEventListener('click', () => setAuthMode('signIn'));
      if (authModeCreate) authModeCreate.addEventListener('click', () => setAuthMode('create'));

      if (authForm) {
        authForm.addEventListener('submit', async (event) => {
          event.preventDefault();
          setAuthError('');

          if (!auth) {
            setAuthError('Firebase is not configured; sign-in is disabled.');
            return;
          }

          const username = authUsername ? authUsername.value.trim() : '';
          const password = authPassword ? authPassword.value : '';
          if (!username) {
            setAuthError('Please enter a username.');
            return;
          }
          if (!password || password.length < 6) {
            setAuthError('Password must be at least 6 characters.');
            return;
          }

          const email = usernameToEmail(username);
          if (!email) {
            setAuthError('Username must include at least one letter or number.');
            return;
          }

          try {
            if (authMode === 'create') {
              const existingUser = auth.currentUser;
              if (existingUser && existingUser.isAnonymous) {
                const credential = EmailAuthProvider.credential(email, password);
                const userCredential = await linkWithCredential(existingUser, credential);
                await updateProfile(userCredential.user, { displayName: username });
              } else {
                const userCredential = await createUserWithEmailAndPassword(auth, email, password);
                await updateProfile(userCredential.user, { displayName: username });
              }
            } else {
              await signInWithEmailAndPassword(auth, email, password);
            }

            closeAuthModal();
          } catch (error) {
            const code = error?.code || '';
            if (code === 'auth/email-already-in-use') {
              setAuthError('That username is already taken. Try signing in instead.');
            } else if (code === 'auth/wrong-password' || code === 'auth/invalid-credential') {
              setAuthError('Incorrect username or password.');
            } else if (code === 'auth/user-not-found') {
              setAuthError('Account not found. Try “Create account”.');
            } else if (code === 'auth/operation-not-allowed') {
              setAuthError('Email/Password sign-in is not enabled in Firebase Auth for this project.');
            } else {
              setAuthError(`Sign-in failed: ${error?.message || 'Unknown error'}`);
            }
          }
        });
      }

      if (authSignOutButton) {
        authSignOutButton.addEventListener('click', async () => {
          setAuthError('');
          if (!auth) return;
          try {
            await signOut(auth);
            // Return to anonymous so leaderboard still works immediately.
            currentUser = await ensureAnonUser();
            updateAuthUiForUser(currentUser);
            updateLeaderboardSubtitleForUser(currentUser);
            await loadLeaderboard();
            closeAuthModal();
          } catch (error) {
            setAuthError(`Sign out failed: ${error?.message || 'Unknown error'}`);
          }
        });
      }

      if (auth) {
        onAuthStateChanged(auth, async (user) => {
          currentUser = user;
          updateAuthUiForUser(user);
          updateLeaderboardSubtitleForUser(user);
          await loadLeaderboard();
        });
      } else {
        updateAuthUiForUser(null);
        updateLeaderboardSubtitleForUser(null);
      }

      window.addEventListener('keydown', (event) => {
        if (event.key !== 'Escape') return;
        // Close account modal first (if open)
        if (authModal && !authModal.classList.contains('hidden')) {
          closeAuthModal();
          return;
        }
        if (!leaderboardModal || leaderboardModal.classList.contains('hidden')) return;
        // Escape: bypass in submit flow, normal close otherwise.
        if (leaderboardModalMode === 'submitWin') {
          finishWinSubmissionFlow({ resetBoard: true });
          return;
        }
        closeLeaderboardModal();
      });

      async function initFirebaseAndLeaderboard() {
        try {
          currentUser = await ensureAnonUser();
          updateAuthUiForUser(currentUser);
          updateLeaderboardSubtitleForUser(currentUser);
          await loadLeaderboard();
        } catch (error) {
          console.error('Failed to initialize Firebase leaderboard', error);
        }
      }

      async function loadLeaderboard() {
        if (!currentUser || !leaderboardList) return;

        try {
          const entriesRef = collection(db, 'leaderboard');
          const q = query(entriesRef, where('userId', '==', currentUser.uid));
          const snapshot = await getDocs(q);
          leaderboardEntries = snapshot.docs.map((docSnap) => ({
            id: docSnap.id,
            ...docSnap.data(),
          })).sort((a, b) => {
            if (b.wins !== a.wins) return b.wins - a.wins;
            return a.name.localeCompare(b.name);
          });
          renderLeaderboard();
        } catch (error) {
          console.error('Failed to load leaderboard', error);
        }
      }

      function renderLeaderboard() {
        if (!leaderboardList) return;

        if (!leaderboardEntries.length) {
          leaderboardList.innerHTML = '<p class=\"leaderboard-empty\">No wins saved yet.</p>';
          return;
        }

        const list = document.createElement('ol');
        list.className = 'leaderboard-items';

        leaderboardEntries.forEach((entry) => {
          const li = document.createElement('li');
          li.className = 'leaderboard-item';
          li.innerHTML = `
            <span class="leaderboard-name">${entry.name}</span>
            <span class="leaderboard-wins">${entry.wins} win${entry.wins === 1 ? '' : 's'}</span>
          `;
          list.appendChild(li);
        });

        leaderboardList.innerHTML = '';
        leaderboardList.appendChild(list);
      }

      async function saveWinForName(name) {
        if (!currentUser) return;

        const trimmedName = name.trim();
        if (!trimmedName) return;

        // Use a safe document id that is unique per user+name
        const baseId = trimmedName.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-_]/g, '') || 'player';
        const safeId = `${currentUser.uid}__${baseId}`;

        try {
          const entryRef = doc(db, 'leaderboard', safeId);
          await setDoc(
            entryRef,
            {
              name: trimmedName,
              userId: currentUser.uid,
              wins: increment(1),
            },
            { merge: true },
          );
          await loadLeaderboard();
        } catch (error) {
          console.error('Failed to save win', error);
        }
      }

      function showNameEntry(winnerSymbol) {
        lastGameWinnerSymbol = winnerSymbol;
        setLeaderboardModalToWinSubmissionView(winnerSymbol);
        openLeaderboardModal({ focusNameInput: true });
      }

      if (leaderboardForm) {
        leaderboardForm.addEventListener('submit', async (event) => {
          event.preventDefault();
          // Only allow one submission per finished game.
          if (leaderboardModalMode !== 'submitWin' || winSubmissionConsumed) return;
          winSubmissionConsumed = true;
          if (playerNameInput) playerNameInput.disabled = true;
          if (leaderboardSubmitButton) {
            leaderboardSubmitButton.disabled = true;
            leaderboardSubmitButton.textContent = 'Saved';
          }

          const name = playerNameInput ? playerNameInput.value : '';
          await saveWinForName(name);

          // After submit, close the popup and reset the board.
          finishWinSubmissionFlow({ resetBoard: true });
        });
      }

      // Initialize the meta board with 9 mini boards
      function initializeGame() {
        metaBoardElement.innerHTML = '';
        
        for (let miniBoardIndex = 0; miniBoardIndex < 9; miniBoardIndex++) {
          const miniBoardWrapper = document.createElement('div');
          miniBoardWrapper.className = 'mini-board-wrapper';
          miniBoardWrapper.id = `mini-board-${miniBoardIndex}`;
          
          const miniBoard = document.createElement('div');
          miniBoard.className = 'mini-board';
          miniBoard.id = `mini-board-grid-${miniBoardIndex}`;
          
          // Create 9 cells for each mini board
          for (let cellIndex = 0; cellIndex < 9; cellIndex++) {
            const cell = document.createElement('button');
            cell.className = 'mini-cell';
            cell.id = `cell-${miniBoardIndex}-${cellIndex}`;
            cell.onclick = () => handleCellClick(miniBoardIndex, cellIndex);
            miniBoard.appendChild(cell);
          }
          
          miniBoardWrapper.appendChild(miniBoard);
          metaBoardElement.appendChild(miniBoardWrapper);
        }

        // At the start, player can play anywhere
        setActiveMiniBoard(activeMiniBoardIndex);
      }

      function handleCellClick(miniBoardIndex, cellIndex) {
        // Enforce active mini-board rule (if one is set)
        if (activeMiniBoardIndex !== null && miniBoardIndex !== activeMiniBoardIndex) {
          // If a specific board is required, ignore clicks on others
          return;
        }

        if (gameOver || boards[miniBoardIndex][cellIndex] !== '' || miniBoardWinners[miniBoardIndex] !== '') {
          return;
        }

        // Place the mark
        boards[miniBoardIndex][cellIndex] = currentPlayer;
        const cell = document.getElementById(`cell-${miniBoardIndex}-${cellIndex}`);
        cell.textContent = currentPlayer.toUpperCase();
        cell.className = `mini-cell ${currentPlayer}`;
        cell.disabled = true;

        // Check if this mini board has a winner
        const miniWinnerResult = checkMiniBoardWinner(miniBoardIndex);
        if (miniWinnerResult) {
          miniBoardWinners[miniBoardIndex] = miniWinnerResult.winner;
          displayMiniBoardWinner(miniBoardIndex, miniWinnerResult.winner, miniWinnerResult.pattern);
          disableMiniBoard(miniBoardIndex);
        } else if (checkMiniBoardDraw(miniBoardIndex)) {
          miniBoardWinners[miniBoardIndex] = 'draw';
          displayMiniBoardDraw(miniBoardIndex);
          disableMiniBoard(miniBoardIndex);
        }

        // Check if overall game is won
        const overallWinner = checkOverallWinner();
        if (overallWinner) {
          messageElement.textContent = `Player ${overallWinner.toUpperCase()} wins the game!`;
          messageElement.style.color = overallWinner === 'x' ? 'red' : 'blue';
          gameOver = true;
          disableAllBoards();
          showNameEntry(overallWinner);
          return;
        }

        // Check if overall game is a draw
        if (checkOverallDraw()) {
          messageElement.textContent = "It's a draw!";
          messageElement.style.color = '#333';
          gameOver = true;
          return;
        }

        // Determine which mini board the next player must play in
        let nextActiveBoard = cellIndex;

        // If that mini board is already won or full, allow next player to play anywhere
        if (!isMiniBoardAvailable(nextActiveBoard)) {
          nextActiveBoard = null;
        }

        setActiveMiniBoard(nextActiveBoard);

        // Switch players
        currentPlayer = currentPlayer === 'x' ? 'o' : 'x';
        updateCurrentPlayerDisplay();
      }

      function checkMiniBoardWinner(miniBoardIndex) {
        const board = boards[miniBoardIndex];
        const winPatterns = [
          { pattern: [0, 1, 2], type: 'horizontal', row: 0 }, // top row
          { pattern: [3, 4, 5], type: 'horizontal', row: 1 }, // middle row
          { pattern: [6, 7, 8], type: 'horizontal', row: 2 }, // bottom row
          { pattern: [0, 3, 6], type: 'vertical', col: 0 }, // left column
          { pattern: [1, 4, 7], type: 'vertical', col: 1 }, // middle column
          { pattern: [2, 5, 8], type: 'vertical', col: 2 }, // right column
          { pattern: [0, 4, 8], type: 'diagonal-1' }, // top-left to bottom-right
          { pattern: [2, 4, 6], type: 'diagonal-2' } // top-right to bottom-left
        ];

        for (let winInfo of winPatterns) {
          const [a, b, c] = winInfo.pattern;
          if (board[a] && board[a] === board[b] && board[a] === board[c]) {
            let patternClass = winInfo.type;
            if (winInfo.type === 'horizontal' && winInfo.row !== undefined) {
              patternClass = `horizontal row-${winInfo.row}`;
            } else if (winInfo.type === 'vertical' && winInfo.col !== undefined) {
              patternClass = `vertical col-${winInfo.col}`;
            }
            return {
              winner: board[a],
              pattern: patternClass,
              winInfo: winInfo
            };
          }
        }
        return null;
      }

      function checkMiniBoardDraw(miniBoardIndex) {
        return boards[miniBoardIndex].every(cell => cell !== '');
      }

      function isMiniBoardAvailable(miniBoardIndex) {
        return miniBoardWinners[miniBoardIndex] === '' && !checkMiniBoardDraw(miniBoardIndex);
      }

      function setActiveMiniBoard(miniBoardIndex) {
        activeMiniBoardIndex = miniBoardIndex;

        for (let i = 0; i < 9; i++) {
          const wrapper = document.getElementById(`mini-board-${i}`);
          if (!wrapper) continue;

          if (miniBoardIndex !== null && i === miniBoardIndex && isMiniBoardAvailable(i)) {
            wrapper.classList.add('active');
          } else {
            wrapper.classList.remove('active');
          }

          for (let j = 0; j < 9; j++) {
            const cell = document.getElementById(`cell-${i}-${j}`);
            if (!cell) continue;

            if (boards[i][j] !== '' || miniBoardWinners[i] !== '') {
              cell.disabled = true;
            } else if (miniBoardIndex === null) {
              // Free to play on any available board
              cell.disabled = false;
            } else {
              // Only cells in the active, available board are playable
              cell.disabled = i !== miniBoardIndex || !isMiniBoardAvailable(i);
            }
          }
        }
      }

      function checkOverallWinner() {
        const winPatterns = [
          [0, 1, 2], [3, 4, 5], [6, 7, 8], // rows
          [0, 3, 6], [1, 4, 7], [2, 5, 8], // columns
          [0, 4, 8], [2, 4, 6] // diagonals
        ];

        for (let pattern of winPatterns) {
          const [a, b, c] = pattern;
          const winnerA = miniBoardWinners[a];
          const winnerB = miniBoardWinners[b];
          const winnerC = miniBoardWinners[c];
          
          if (winnerA && winnerA === winnerB && winnerA === winnerC && winnerA !== 'draw') {
            return winnerA;
          }
        }
        return null;
      }

      function checkOverallDraw() {
        return miniBoardWinners.every(winner => winner !== '');
      }

      function displayMiniBoardWinner(miniBoardIndex, winner, patternType) {
        const miniBoardWrapper = document.getElementById(`mini-board-${miniBoardIndex}`);
        const miniBoard = document.getElementById(`mini-board-grid-${miniBoardIndex}`);
        
        // Mark the wrapper as won to fade cells
        miniBoardWrapper.classList.add('won');
        
        // Create the winning line
        const winningLine = document.createElement('div');
        winningLine.className = `winning-line ${winner} ${patternType}`;
        miniBoard.appendChild(winningLine);
        
        // Create the large symbol display
        const winnerDisplay = document.createElement('div');
        winnerDisplay.className = `mini-board-winner ${winner}`;
        winnerDisplay.textContent = winner.toUpperCase();
        miniBoardWrapper.appendChild(winnerDisplay);
      }

      function displayMiniBoardDraw(miniBoardIndex) {
        const miniBoardWrapper = document.getElementById(`mini-board-${miniBoardIndex}`);
        miniBoardWrapper.classList.add('draw');
      }

      function disableMiniBoard(miniBoardIndex) {
        for (let i = 0; i < 9; i++) {
          const cell = document.getElementById(`cell-${miniBoardIndex}-${i}`);
          if (cell) {
            cell.disabled = true;
          }
        }
      }

      function disableAllBoards() {
        for (let i = 0; i < 9; i++) {
          disableMiniBoard(i);
        }
      }

      function updateCurrentPlayerDisplay() {
        bodyElement.className = currentPlayer;
        bodyElement.setAttribute('data-symbol', currentPlayer.toUpperCase());
      }

      function resetGame() {
        currentPlayer = 'x';
        gameOver = false;
        boards = Array(9).fill(null).map(() => Array(9).fill(''));
        miniBoardWinners = Array(9).fill('');
        activeMiniBoardIndex = null;
        messageElement.textContent = '';
        initializeGame();
        updateCurrentPlayerDisplay();
      }

      // Initialize the game on load
      initializeGame();
      updateCurrentPlayerDisplay();
      initFirebaseAndLeaderboard();

      // Make resetGame callable from the inline HTML button handler.
      window.resetGame = resetGame;
    </script>
  </body>
</html>
